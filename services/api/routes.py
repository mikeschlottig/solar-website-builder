# Auto-generated by Lumenary
##############################################################################
# Dependencies
##############################################################################


from fastapi import Depends, FastAPI, HTTPException, Request, status, Body, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import HTMLResponse, Response

from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse, Response
from fastapi.exceptions import RequestValidationError
from fastapi.security import OAuth2PasswordBearer

import sys
import os
import asyncio
import logging
import traceback
import contextvars
import httpx
import jwt
import json
import requests
from pathlib import Path
import builtins

from datetime import datetime, date, time, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Callable, Any, TypeVar, Awaitable, List, Optional, Dict, Union, Literal, Annotated, Tuple, Set
from functools import partial, wraps
from uuid import UUID
import uuid

from solar.access import User
from solar.media import MediaFile

from api.utils import get_swagger_ui_html
from api.models import TokenExchangeRequest, TokenResponse, TokenValidationRequest, LogoutResponse

OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")
ROUTER_BASE_URL = os.environ.get("ROUTER_BASE_URL")
SOLAR_APP_TOKEN_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/token"
SOLAR_APP_INTROSPECT_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/introspect"
REFRESH_TOKEN_COOKIE_NAME = "refresh_token"

from .models import BodyWebsiteServiceCreateWebsite, CreateWebsiteOutputSchema, GetUserWebsitesOutputSchema, BodyWebsiteServiceGetWebsite, GetWebsiteOutputSchema, BodyWebsiteServiceUpdateWebsite, UpdateWebsiteOutputSchema, UploadFaviconOutputSchema, BodyWebsiteServiceDeleteWebsite, DeleteWebsiteOutputSchema, BodyWebsiteServicePublishWebsite, PublishWebsiteOutputSchema, BodyComponentServiceCreateCustomComponent, CreateCustomComponentOutputSchema, BodyComponentServiceGetUserComponents, GetUserComponentsOutputSchema, GetBuiltInComponentsOutputSchema, BodyComponentServiceGetPublicComponents, GetPublicComponentsOutputSchema, BodyComponentServiceGetComponent, GetComponentOutputSchema, BodyComponentServiceUpdateComponent, UpdateComponentOutputSchema, UploadComponentPreviewOutputSchema, BodyComponentServiceDeleteComponent, DeleteComponentOutputSchema, BodyComponentServiceValidateComponentCode, ValidateComponentCodeOutputSchema, UploadMediaOutputSchema, BodyMediaServiceGetUserMedia, GetUserMediaOutputSchema, BodyMediaServiceGetMediaAsset, GetMediaAssetOutputSchema, BodyMediaServiceUpdateMediaMetadata, UpdateMediaMetadataOutputSchema, BodyMediaServiceDeleteMediaAsset, DeleteMediaAssetOutputSchema, BodyMediaServiceOrganizeMedia, OrganizeMediaOutputSchema, BodyPageServiceCreatePage, CreatePageOutputSchema, BodyPageServiceGetWebsitePages, GetWebsitePagesOutputSchema, BodyPageServiceGetPage, GetPageOutputSchema, BodyPageServiceUpdatePageContent, UpdatePageContentOutputSchema, BodyPageServiceUpdatePageMetadata, UpdatePageMetadataOutputSchema, BodyPageServiceUpdatePageStyles, UpdatePageStylesOutputSchema, BodyPageServicePublishPage, PublishPageOutputSchema, BodyPageServiceDeletePage, DeletePageOutputSchema, BodyPageServiceReorderPages, ReorderPagesOutputSchema
from core import website_service, component_service, media_service, page_service

from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional, Dict, Any
from pydantic import BaseModel

from ..core.component_service import component_service
from ..core.component import Component
from ..core.media_service import media_service
from ..core.page_service import page_service
from ..core.website_service import website_service

router = APIRouter()

# Component routes
class ComponentResponse(BaseModel):
    id: str
    name: str
    description: Optional[str]
    category: str
    component_type: str
    props_schema: dict
    version: str

class CreateComponentRequest(BaseModel):
    name: str
    description: Optional[str] = None
    category: str = "custom"
    code: str
    styles: Optional[str] = None
    props_schema: Optional[dict] = None

@router.get("/components/built-in", response_model=List[ComponentResponse])
async def get_built_in_components():
    """Get all built-in components"""
    try:
        components = component_service.get_built_in_components()
        return [
            ComponentResponse(
                id=comp.id,
                name=comp.name,
                description=comp.description,
                category=comp.category,
                component_type=comp.component_type,
                props_schema=comp.props_schema or {},
                version=comp.version or "1.0.0"
            )
            for comp in components
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/components/user", response_model=List[ComponentResponse])
async def get_user_components(current_user: User = Depends(get_current_user)):
    """Get user's custom components"""
    try:
        components = component_service.get_user_components(current_user.id)
        return [
            ComponentResponse(
                id=comp.id,
                name=comp.name,
                description=comp.description,
                category=comp.category,
                component_type=comp.component_type,
                props_schema=comp.props_schema or {},
                version=comp.version or "1.0.0"
            )
            for comp in components
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/components", response_model=ComponentResponse)
async def create_component(
    request: CreateComponentRequest,
    current_user: User = Depends(get_current_user)
):
    """Create a new custom component"""
    try:
        component = Component(
            user_id=current_user.id,
            name=request.name,
            description=request.description,
            category=request.category,
            component_type="custom",
            code=request.code,
            styles=request.styles or "",
            props_schema=request.props_schema or {},
            is_public=False
        )
        
        created_component = component_service.create_custom_component(component)
        
        return ComponentResponse(
            id=created_component.id,
            name=created_component.name,
            description=created_component.description,
            category=created_component.category,
            component_type=created_component.component_type,
            props_schema=created_component.props_schema or {},
            version=created_component.version or "1.0.0"
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/components/{component_id}", response_model=ComponentResponse)
async def get_component(
    component_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get a specific component by ID"""
    try:
        component = component_service.get_component_by_id(component_id)
        if not component:
            raise HTTPException(status_code=404, detail="Component not found")
        
        return ComponentResponse(
            id=component.id,
            name=component.name,
            description=component.description,
            category=component.category,
            component_type=component.component_type,
            props_schema=component.props_schema or {},
            version=component.version or "1.0.0"
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/components/{component_id}")
async def delete_component(
    component_id: str,
    current_user: User = Depends(get_current_user)
):
    """Delete a custom component"""
    try:
        success = component_service.delete_component(component_id)
        if not success:
            raise HTTPException(status_code=404, detail="Component not found or access denied")
        
        return {"message": "Component deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Media routes
class GetUserMediaRequest(BaseModel):
    website_id: Optional[str] = None
    mime_type_filter: Optional[str] = None

@router.post("/media/user")
async def get_user_media(request: GetUserMediaRequest):
    """Get user's media assets"""
    try:
        media_assets = media_service.get_user_media(
            website_id=request.website_id,
            mime_type_filter=request.mime_type_filter
        )
        return {"data": media_assets}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Page routes
class CreatePageRequest(BaseModel):
    website_id: str
    name: str
    path: str
    content: Optional[Dict[str, Any]] = None

@router.post("/pages")
async def create_page(request: CreatePageRequest):
    """Create a new page"""
    try:
        page = page_service.create_page(
            website_id=request.website_id,
            name=request.name,
            path=request.path,
            content=request.content or {}
        )
        return {"data": page}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

class UpdatePageRequest(BaseModel):
    content: Dict[str, Any]

@router.put("/pages/{page_id}")
async def update_page(page_id: str, request: UpdatePageRequest):
    """Update a page's content"""
    try:
        page = page_service.update_page_content(page_id, request.content)
        if not page:
            raise HTTPException(status_code=404, detail="Page not found")
        return {"data": page}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/pages/{page_id}")
async def get_page(page_id: str):
    """Get a specific page"""
    try:
        page = page_service.get_page(page_id)
        if not page:
            raise HTTPException(status_code=404, detail="Page not found")
        return {"data": page}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Website routes
class CreateWebsiteRequest(BaseModel):
    name: str
    domain: Optional[str] = None

@router.post("/websites")
async def create_website(request: CreateWebsiteRequest):
    """Create a new website"""
    try:
        website = website_service.create_website(
            name=request.name,
            domain=request.domain
        )
        return {"data": website}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/websites/{website_id}")
async def get_website(website_id: str):
    """Get a specific website"""
    try:
        website = website_service.get_website(website_id)
        if not website:
            raise HTTPException(status_code=404, detail="Website not found")
        return {"data": website}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/websites/{website_id}/pages")
async def get_website_pages(website_id: str):
    """Get all pages for a website"""
    try:
        pages = page_service.get_website_pages(website_id)
        return {"data": pages}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

###############################################################################
# Logging Setup
###############################################################################
import sys
from loguru import logger
from pathlib import Path
from typing import TypeVar
import traceback

def format_record(record):
    fmt = "{level:<5} | {message}"
    if record["exception"] is not None:
        exc_type, exc_value, exc_traceback = record["exception"]        
        tb_lines = traceback.extract_tb(exc_traceback)
        if tb_lines:
            last_frame = tb_lines[-1]
            error_info = (
                f'\nFile "{last_frame.filename}", line {last_frame.lineno}, in {last_frame.name}\n'
                f'  {last_frame.line}\n'
                f'{exc_type.__name__}: {exc_value}'
            )
            record["message"] += error_info
        
        record["exception"] = None
    
    return fmt + "\n"

logger.remove()
logger.add(
    sys.stderr,
    level="DEBUG",
    format=format_record,
    colorize=True
)

Path("../logs").mkdir(exist_ok=True)
logger.add(
    "../logs/fast_api.log",
    rotation="50 MB",
    retention="10 days",
    level="DEBUG",
    format=format_record
)

# need this to capture print statements
class InterceptHandler:
    def write(self, msg):
        if msg.strip():
            logger.info(msg.strip())
    
    def flush(self):
        pass

sys.stdout = InterceptHandler()

T = TypeVar('T')

###############################################################################
# General App
##############################################################################

app = FastAPI(
    title="Next.js Website CMS",
    docs_url=None
)

app.include_router(router)

###############################################################################
# Simple Request Logging Middleware
###############################################################################

@app.middleware("http")
async def log_requests(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    
    with logger.contextualize(request_id=request_id):
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            process_time = (datetime.utcnow() - start_time).total_seconds()
            if "HEAD /docs" not in request.url.path:
              logger.info(f"{request.method} {request.url.path} ({response.status_code}) - {process_time:.3f}s")
            return response
        except Exception as e:
            process_time = (datetime.utcnow() - start_time).total_seconds()
            logger.exception(f"{request.method} {request.url.path} - Failed after {process_time:.3f}s")
            raise
            
###############################################################################
# Error Handler
###############################################################################
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors"""
    logger.error(f"Unhandled exception on {request.method} {request.url.path}: {exc}", exc_info=True)
    
    # In production, don't expose error details
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
        }
    )
    
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle pydantic validation errors"""
    logger.error(f"Validation error on {request.url.path}: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "message": "Invalid request parameters",
            "details": exc.errors()
        }
    )
    
@app.exception_handler(Exception)
async def handle_errors(request: Request, exc: Exception):
    logger.exception(f"Unhandled error: {type(exc).__name__}: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "message": str(exc)}
    )

@app.exception_handler(RequestValidationError)
async def handle_validation_errors(request: Request, exc: RequestValidationError):
    logger.warning(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={"error": "Validation failed", "details": exc.errors()}
    )

# We need to put a token endpoint here, but we're injecting the token,
# so we'll just put a mock endpoint here.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/mockedTokenEndpoint/")
ENV = os.environ.get("ENV", "deployment")

def get_auth_origins():
    if ENV == "sandbox":
        origins = [
            os.environ.get("SANDBOX_FRONTEND_URL", ""),
            os.environ.get("SANDBOX_BACKEND_URL", ""),
        ]
    else:
        origins = [os.environ.get("PUBLIC_DOMAIN", "")]
    
    return [origin for origin in origins if origin]

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

async def auth_cors_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/auth"):
        auth_origins = get_auth_origins()
        origin = request.headers.get("origin", "")
        response = await call_next(request)
        
        # override the wildcard CORS settings with strict origin checking
        if origin in auth_origins:
            response.headers["Access-Control-Allow-Origin"] = origin
            response.headers["Access-Control-Allow-Credentials"] = "true"
            response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
            response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
            response.headers["Access-Control-Expose-Headers"] = "Set-Cookie"
        else:
            # unauthorized origins on auth routes, set CORS headers to blank or remove them
            response.headers["Access-Control-Allow-Origin"] = ""
            response.headers["Access-Control-Allow-Methods"] = ""
            response.headers["Access-Control-Allow-Headers"] = ""
            
        return response
    else:
        return await call_next(request)

# auth-specific middleware and logging middleware
app.middleware("http")(auth_cors_middleware)

# OPTIONS handler for auth endpoints
@app.options("/api/auth/{rest_of_path:path}", include_in_schema=False)
async def auth_options_handler(request: Request):
    auth_origins = get_auth_origins()
    origin = request.headers.get("origin", "")
    response = Response()
    
    if origin in auth_origins:
        response.headers["Access-Control-Allow-Origin"] = origin
        response.headers["Access-Control-Allow-Credentials"] = "true"
        response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
        response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
        response.headers["Access-Control-Max-Age"] = "3600"
    
    return response

@app.head("/docs", include_in_schema=False)
async def health_check():
    return {"status": "healthy"}
    
##############################################################################
# Synchronous Function Helpers
##############################################################################

thread_pool = ThreadPoolExecutor(max_workers=4)

async def run_sync_in_thread(func: Callable[..., Any], *args, **kwargs) -> Any:
    """Runs a synchronous function in a thread pool"""
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(
        thread_pool,
        partial(func, *args, **kwargs)
    )


##############################################################################
# Custom Docs
##############################################################################

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " on Solar",
        swagger_ui_parameters={
            "persistAuthorization": False,
            "syntaxHighlight": {"theme": "obsidian"},
        }
    )

##############################################################################
# Auth Routes
##############################################################################

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        base_url = os.getenv("ROUTER_BASE_URL")
        if not base_url:
            raise HTTPException(status_code=500, detail="ROUTER_BASE_URL is not set, could not authenticate user")
        
        try:
            decoded_token = jwt.decode(token, options={"verify_signature": False})
            
            jti = decoded_token.get("jti")
            if not jti:
                raise HTTPException(status_code=401, detail="Invalid token format")
            
            exp = decoded_token.get("exp")
            if exp is not None and exp < datetime.utcnow().timestamp():
                raise HTTPException(status_code=401, detail="Token expired")
        
        except jwt.DecodeError:
            raise HTTPException(status_code=401, detail="Malformed token")
        
        token_url = f"{base_url}/innerApp/oauth2/introspect"
        async with httpx.AsyncClient(timeout=20.0) as client:
            response = await client.post(token_url, json={"token": jti, "token_type_hint": "access_token"})
            if response.status_code != 200:
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            json_response = response.json()
            if not json_response.get("active", False):
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            user_uuid = json_response.get("userUuid")
            email = json_response.get("email")
            if not user_uuid or not email:
                raise HTTPException(status_code=401, detail="Invalid user data")
            
            user = User(id=user_uuid, email=email)
            return user
    except HTTPException:
        raise
    except Exception as e:
        print(f"get_current_user failed with error: {type(e).__name__}")
        raise HTTPException(status_code=401, detail="Unauthorized")

def extract_domain(url):
    if not url:
        return None
    
    # Remove protocol
    if url.startswith("http://"):
        url = url[7:]
    elif url.startswith("https://"):
        url = url[8:]
    
    # Remove trailing slash
    if url.endswith("/"):
        url = url[:-1]
    
    return url

@app.post('/api/auth/token', response_model=TokenResponse, include_in_schema=False)
async def exchange_token(request: Request, body: TokenExchangeRequest = Body(...)):    
    try:
        params = body.model_dump(exclude_none=True)
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME:
            refresh_token = request.cookies.get(REFRESH_TOKEN_COOKIE_NAME)
            if not refresh_token:
                return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authentication required",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )

            params[REFRESH_TOKEN_COOKIE_NAME] = refresh_token
        
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME and params.get(REFRESH_TOKEN_COOKIE_NAME):
            try:
                refresh_token = params[REFRESH_TOKEN_COOKIE_NAME]
                payload = jwt.decode(refresh_token, options={"verify_signature": False})
                
                if payload and payload.get("jti"):
                    params[REFRESH_TOKEN_COOKIE_NAME] = payload["jti"]
            except Exception as e:
                logger.warning("Error extracting JTI from refresh token")

        response = requests.post(
            SOLAR_APP_TOKEN_URL,
            json=params,
            headers={"Content-Type": "application/json", "Accept": "application/json"}
        )
        
        if not response.ok:
            return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authorization code invalid or expired",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )
        
        tokens = response.json()
        
        # Safe null check for access token
        access_token = tokens.get("access_token")
        if not access_token:
            return HTTPException(status_code=401, detail="Received incomplete token data from server")
        
        token_response = TokenResponse(
            access_token=access_token,
            token_type=tokens.get("token_type", "bearer"),
            expires_in=tokens.get("expires_in", 3600)
        )
        
        content = token_response.model_dump()
        api_response = JSONResponse(content=content)
        
        # Safe null check for refresh token
        refresh_token_value = tokens.get(REFRESH_TOKEN_COOKIE_NAME)
        if refresh_token_value:
            if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
              return HTTPException(status_code=401, detail="Token exchange failed: sandbox frontend URL not set")
            
            if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
              return HTTPException(status_code=401, detail="Token exchange failed: public domain not set")
            
            domain = None
            if ENV == "sandbox":
                domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
            else:
                domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))

            api_response.set_cookie(
                key=REFRESH_TOKEN_COOKIE_NAME,
                value=refresh_token_value,
                httponly=True,
                secure=True,
                samesite="none" if ENV == "sandbox" else "strict",
                domain=domain,
                path="/api/auth"
            )
        
        return api_response
        
    except Exception as e:
        return HTTPException(status_code=401, detail=f"Token exchange failed: {str(e)}")


@app.post('/api/auth/logout', response_model=LogoutResponse, include_in_schema=False)
async def logout():
    response = JSONResponse(content={"success": True})
    
    if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
      return HTTPException(status_code=401, detail="Logout failed: sandbox frontend URL not set")
    
    if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
      return HTTPException(status_code=401, detail="Logout failed: public domain not set")
    
    domain = None
    if ENV == "sandbox":
        domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
    else:
        domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))
    
    response.delete_cookie(
        key=REFRESH_TOKEN_COOKIE_NAME,
        path="/api/auth",
        secure=True,
        httponly=True,
        samesite="none" if ENV == "sandbox" else "strict",
        domain=domain,
    )
    
    return response


##############################################################################
# Normal Routes
##############################################################################






@app.post('/api/website_service/create_website', response_model=CreateWebsiteOutputSchema, operation_id='website_service_create_website')
async def website_service_create_website(body: BodyWebsiteServiceCreateWebsite = Body(...), current_user: User = Depends(get_current_user)) -> CreateWebsiteOutputSchema:
    """
    Create a new website for the authenticated user.
    """
    response = await run_sync_in_thread(website_service.create_website, user=current_user, name=body.name, description=body.description)
    return response
    
    




@app.post('/api/website_service/get_user_websites', response_model=GetUserWebsitesOutputSchema, operation_id='website_service_get_user_websites')
async def website_service_get_user_websites(current_user: User = Depends(get_current_user)) -> GetUserWebsitesOutputSchema:
    """
    Get all websites belonging to the authenticated user.
    """
    response = await run_sync_in_thread(website_service.get_user_websites, user=current_user)
    return response
    
    




@app.post('/api/website_service/get_website', response_model=GetWebsiteOutputSchema, operation_id='website_service_get_website')
async def website_service_get_website(body: BodyWebsiteServiceGetWebsite = Body(...), current_user: User = Depends(get_current_user)) -> GetWebsiteOutputSchema:
    """
    Get a specific website belonging to the authenticated user.
    """
    response = await run_sync_in_thread(website_service.get_website, user=current_user, website_id=body.website_id)
    return response
    
    




@app.post('/api/website_service/update_website', response_model=UpdateWebsiteOutputSchema, operation_id='website_service_update_website')
async def website_service_update_website(body: BodyWebsiteServiceUpdateWebsite = Body(...), current_user: User = Depends(get_current_user)) -> UpdateWebsiteOutputSchema:
    """
    Update website settings.
    """
    response = await run_sync_in_thread(website_service.update_website, user=current_user, website_id=body.website_id, name=body.name, description=body.description, domain=body.domain, theme_config=body.theme_config, seo_config=body.seo_config)
    return response
    
    




@app.post('/api/website_service/upload_favicon', response_model=UploadFaviconOutputSchema, operation_id='website_service_upload_favicon')
async def website_service_upload_favicon(favicon: UploadFile = File(...), website_id: UUID = Form(...), current_user: User = Depends(get_current_user)) -> UploadFaviconOutputSchema:
    """
    Upload and set favicon for a website.
    """
    # Download favicon from the client
    if favicon is not None:
        content_type = favicon.content_type or "application/octet-stream"
        contents = await favicon.read()
        file_size = len(contents)
        favicon = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(website_service.upload_favicon, user=current_user, website_id=website_id, favicon=favicon)
    return response
    
    




@app.post('/api/website_service/delete_website', response_model=DeleteWebsiteOutputSchema, operation_id='website_service_delete_website')
async def website_service_delete_website(body: BodyWebsiteServiceDeleteWebsite = Body(...), current_user: User = Depends(get_current_user)) -> DeleteWebsiteOutputSchema:
    """
    Delete a website and all its associated data.
    """
    response = await run_sync_in_thread(website_service.delete_website, user=current_user, website_id=body.website_id)
    return response
    
    




@app.post('/api/website_service/publish_website', response_model=PublishWebsiteOutputSchema, operation_id='website_service_publish_website')
async def website_service_publish_website(body: BodyWebsiteServicePublishWebsite = Body(...), current_user: User = Depends(get_current_user)) -> PublishWebsiteOutputSchema:
    """
    Publish a website (make it live).
    """
    response = await run_sync_in_thread(website_service.publish_website, user=current_user, website_id=body.website_id)
    return response
    
    




@app.post('/api/component_service/create_custom_component', response_model=CreateCustomComponentOutputSchema, operation_id='component_service_create_custom_component')
async def component_service_create_custom_component(body: BodyComponentServiceCreateCustomComponent = Body(...), current_user: User = Depends(get_current_user)) -> CreateCustomComponentOutputSchema:
    """
    Create a new custom React component.
    """
    response = await run_sync_in_thread(component_service.create_custom_component, user=current_user, name=body.name, code=body.code, description=body.description, category=body.category, styles=body.styles, props_schema=body.props_schema)
    return response
    
    




@app.post('/api/component_service/get_user_components', response_model=GetUserComponentsOutputSchema, operation_id='component_service_get_user_components')
async def component_service_get_user_components(body: BodyComponentServiceGetUserComponents = Body(...), current_user: User = Depends(get_current_user)) -> GetUserComponentsOutputSchema:
    """
    Get all components created by the user, optionally filtered by category.
    """
    response = await run_sync_in_thread(component_service.get_user_components, user=current_user, category=body.category)
    return response
    
    




@app.post('/api/component_service/get_built_in_components', response_model=GetBuiltInComponentsOutputSchema, operation_id='component_service_get_built_in_components')
async def component_service_get_built_in_components() -> GetBuiltInComponentsOutputSchema:
    """
    Get all built-in components available to all users.
    """
    response = await run_sync_in_thread(component_service.get_built_in_components)
    return response
    
    




@app.post('/api/component_service/get_public_components', response_model=GetPublicComponentsOutputSchema, operation_id='component_service_get_public_components')
async def component_service_get_public_components(body: BodyComponentServiceGetPublicComponents = Body(...)) -> GetPublicComponentsOutputSchema:
    """
    Get all public custom components, optionally filtered by category.
    """
    response = await run_sync_in_thread(component_service.get_public_components, category=body.category)
    return response
    
    




@app.post('/api/component_service/get_component', response_model=GetComponentOutputSchema, operation_id='component_service_get_component')
async def component_service_get_component(body: BodyComponentServiceGetComponent = Body(...), current_user: User = Depends(get_current_user)) -> GetComponentOutputSchema:
    """
    Get a specific component with ownership verification.
    """
    response = await run_sync_in_thread(component_service.get_component, user=current_user, component_id=body.component_id)
    return response
    
    




@app.post('/api/component_service/update_component', response_model=UpdateComponentOutputSchema, operation_id='component_service_update_component')
async def component_service_update_component(body: BodyComponentServiceUpdateComponent = Body(...), current_user: User = Depends(get_current_user)) -> UpdateComponentOutputSchema:
    """
    Update a custom component.
    """
    response = await run_sync_in_thread(component_service.update_component, user=current_user, component_id=body.component_id, name=body.name, description=body.description, code=body.code, styles=body.styles, props_schema=body.props_schema, is_public=body.is_public)
    return response
    
    




@app.post('/api/component_service/upload_component_preview', response_model=UploadComponentPreviewOutputSchema, operation_id='component_service_upload_component_preview')
async def component_service_upload_component_preview(component_id: UUID = Form(...), preview_image: UploadFile = File(...), current_user: User = Depends(get_current_user)) -> UploadComponentPreviewOutputSchema:
    """
    Upload a preview image for a component.
    """
    # Download preview_image from the client
    if preview_image is not None:
        content_type = preview_image.content_type or "application/octet-stream"
        contents = await preview_image.read()
        file_size = len(contents)
        preview_image = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(component_service.upload_component_preview, user=current_user, component_id=component_id, preview_image=preview_image)
    return response
    
    




@app.post('/api/component_service/delete_component', response_model=DeleteComponentOutputSchema, operation_id='component_service_delete_component')
async def component_service_delete_component(body: BodyComponentServiceDeleteComponent = Body(...), current_user: User = Depends(get_current_user)) -> DeleteComponentOutputSchema:
    """
    Delete a custom component.
    """
    response = await run_sync_in_thread(component_service.delete_component, user=current_user, component_id=body.component_id)
    return response
    
    




@app.post('/api/component_service/validate_component_code', response_model=ValidateComponentCodeOutputSchema, operation_id='component_service_validate_component_code')
async def component_service_validate_component_code(body: BodyComponentServiceValidateComponentCode = Body(...), current_user: User = Depends(get_current_user)) -> ValidateComponentCodeOutputSchema:
    """
    Validate React component code and return any errors or warnings.
    """
    response = await run_sync_in_thread(component_service.validate_component_code, user=current_user, code=body.code)
    return response
    
    




@app.post('/api/media_service/upload_media', response_model=UploadMediaOutputSchema, operation_id='media_service_upload_media')
async def media_service_upload_media(alt_text: Optional[str] = Form(None), file: UploadFile = File(...), folder: Optional[str] = Form(None), name: str = Form(...), tags: Optional[List[str]] = Form(None), website_id: Optional[UUID] = Form(None), current_user: User = Depends(get_current_user)) -> UploadMediaOutputSchema:
    """
    Upload a media file and create a database record.
    """
    # Download file from the client
    if file is not None:
        content_type = file.content_type or "application/octet-stream"
        contents = await file.read()
        file_size = len(contents)
        file = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(media_service.upload_media, user=current_user, file=file, name=name, website_id=website_id, alt_text=alt_text, folder=folder, tags=tags)
    return response
    
    




@app.post('/api/media_service/get_user_media', response_model=GetUserMediaOutputSchema, operation_id='media_service_get_user_media')
async def media_service_get_user_media(body: BodyMediaServiceGetUserMedia = Body(...), current_user: User = Depends(get_current_user)) -> GetUserMediaOutputSchema:
    """
    Get media assets for a user, optionally filtered by website, folder, or type.
    """
    response = await run_sync_in_thread(media_service.get_user_media, user=current_user, website_id=body.website_id, folder=body.folder, mime_type_filter=body.mime_type_filter)
    return response
    
    




@app.post('/api/media_service/get_media_asset', response_model=GetMediaAssetOutputSchema, operation_id='media_service_get_media_asset')
async def media_service_get_media_asset(body: BodyMediaServiceGetMediaAsset = Body(...), current_user: User = Depends(get_current_user)) -> GetMediaAssetOutputSchema:
    """
    Get a specific media asset with ownership verification.
    """
    response = await run_sync_in_thread(media_service.get_media_asset, user=current_user, asset_id=body.asset_id)
    return response
    
    




@app.post('/api/media_service/update_media_metadata', response_model=UpdateMediaMetadataOutputSchema, operation_id='media_service_update_media_metadata')
async def media_service_update_media_metadata(body: BodyMediaServiceUpdateMediaMetadata = Body(...), current_user: User = Depends(get_current_user)) -> UpdateMediaMetadataOutputSchema:
    """
    Update media asset metadata.
    """
    response = await run_sync_in_thread(media_service.update_media_metadata, user=current_user, asset_id=body.asset_id, name=body.name, alt_text=body.alt_text, tags=body.tags, folder=body.folder)
    return response
    
    




@app.post('/api/media_service/delete_media_asset', response_model=DeleteMediaAssetOutputSchema, operation_id='media_service_delete_media_asset')
async def media_service_delete_media_asset(body: BodyMediaServiceDeleteMediaAsset = Body(...), current_user: User = Depends(get_current_user)) -> DeleteMediaAssetOutputSchema:
    """
    Delete a media asset and its file from storage.
    """
    response = await run_sync_in_thread(media_service.delete_media_asset, user=current_user, asset_id=body.asset_id)
    return response
    
    




@app.post('/api/media_service/organize_media', response_model=OrganizeMediaOutputSchema, operation_id='media_service_organize_media')
async def media_service_organize_media(body: BodyMediaServiceOrganizeMedia = Body(...), current_user: User = Depends(get_current_user)) -> OrganizeMediaOutputSchema:
    """
    Move multiple media assets to a different folder.
    """
    response = await run_sync_in_thread(media_service.organize_media, user=current_user, asset_ids=body.asset_ids, target_folder=body.target_folder)
    return response
    
    




@app.post('/api/page_service/create_page', response_model=CreatePageOutputSchema, operation_id='page_service_create_page')
async def page_service_create_page(body: BodyPageServiceCreatePage = Body(...), current_user: User = Depends(get_current_user)) -> CreatePageOutputSchema:
    """
    Create a new page for a website.
    """
    response = await run_sync_in_thread(page_service.create_page, user=current_user, website_id=body.website_id, title=body.title, slug=body.slug, meta_description=body.meta_description)
    return response
    
    




@app.post('/api/page_service/get_website_pages', response_model=GetWebsitePagesOutputSchema, operation_id='page_service_get_website_pages')
async def page_service_get_website_pages(body: BodyPageServiceGetWebsitePages = Body(...), current_user: User = Depends(get_current_user)) -> GetWebsitePagesOutputSchema:
    """
    Get all pages for a website.
    """
    response = await run_sync_in_thread(page_service.get_website_pages, user=current_user, website_id=body.website_id)
    return response
    
    




@app.post('/api/page_service/get_page', response_model=GetPageOutputSchema, operation_id='page_service_get_page')
async def page_service_get_page(body: BodyPageServiceGetPage = Body(...), current_user: User = Depends(get_current_user)) -> GetPageOutputSchema:
    """
    Get a specific page with ownership verification.
    """
    response = await run_sync_in_thread(page_service.get_page, user=current_user, page_id=body.page_id)
    return response
    
    




@app.post('/api/page_service/update_page_content', response_model=UpdatePageContentOutputSchema, operation_id='page_service_update_page_content')
async def page_service_update_page_content(body: BodyPageServiceUpdatePageContent = Body(...), current_user: User = Depends(get_current_user)) -> UpdatePageContentOutputSchema:
    """
    Update the content structure of a page.
    """
    response = await run_sync_in_thread(page_service.update_page_content, user=current_user, page_id=body.page_id, content_structure=body.content_structure)
    return response
    
    




@app.post('/api/page_service/update_page_metadata', response_model=UpdatePageMetadataOutputSchema, operation_id='page_service_update_page_metadata')
async def page_service_update_page_metadata(body: BodyPageServiceUpdatePageMetadata = Body(...), current_user: User = Depends(get_current_user)) -> UpdatePageMetadataOutputSchema:
    """
    Update page metadata.
    """
    response = await run_sync_in_thread(page_service.update_page_metadata, user=current_user, page_id=body.page_id, title=body.title, slug=body.slug, meta_description=body.meta_description, meta_keywords=body.meta_keywords)
    return response
    
    




@app.post('/api/page_service/update_page_styles', response_model=UpdatePageStylesOutputSchema, operation_id='page_service_update_page_styles')
async def page_service_update_page_styles(body: BodyPageServiceUpdatePageStyles = Body(...), current_user: User = Depends(get_current_user)) -> UpdatePageStylesOutputSchema:
    """
    Update page-specific styles.
    """
    response = await run_sync_in_thread(page_service.update_page_styles, user=current_user, page_id=body.page_id, styles=body.styles)
    return response
    
    




@app.post('/api/page_service/publish_page', response_model=PublishPageOutputSchema, operation_id='page_service_publish_page')
async def page_service_publish_page(body: BodyPageServicePublishPage = Body(...), current_user: User = Depends(get_current_user)) -> PublishPageOutputSchema:
    """
    Publish a page.
    """
    response = await run_sync_in_thread(page_service.publish_page, user=current_user, page_id=body.page_id)
    return response
    
    




@app.post('/api/page_service/delete_page', response_model=DeletePageOutputSchema, operation_id='page_service_delete_page')
async def page_service_delete_page(body: BodyPageServiceDeletePage = Body(...), current_user: User = Depends(get_current_user)) -> DeletePageOutputSchema:
    """
    Delete a page.
    """
    response = await run_sync_in_thread(page_service.delete_page, user=current_user, page_id=body.page_id)
    return response
    
    




@app.post('/api/page_service/reorder_pages', response_model=ReorderPagesOutputSchema, operation_id='page_service_reorder_pages')
async def page_service_reorder_pages(body: BodyPageServiceReorderPages = Body(...), current_user: User = Depends(get_current_user)) -> ReorderPagesOutputSchema:
    """
    Reorder pages by updating their sort_order values.
    """
    response = await run_sync_in_thread(page_service.reorder_pages, user=current_user, website_id=body.website_id, page_orders=body.page_orders)
    return response
